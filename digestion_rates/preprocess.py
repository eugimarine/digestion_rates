# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_SeqCell.ipynb.

# %% auto 0
__all__ = ['extract_umi_cb', 'parse_plate', 'SequencesCells', 'filter_group', 'concat_plates']

# %% ../01_SeqCell.ipynb 3
import numpy as np
import pandas as pd
import gzip
from Bio import SeqIO
from pathlib import Path
from multiprocessing import Pool

# %% ../01_SeqCell.ipynb 5
def extract_umi_cb(nm):
    nm = nm.split(' ')[0]
    cb, umi = nm.split('_')[1:3]
    return umi, cb

# %% ../01_SeqCell.ipynb 7
def parse_plate(path, plate_name):
    ids = []
    with gzip.open(path, "rt") as handle:
        for record in SeqIO.parse(handle, "fastq"):
            umi, cb = extract_umi_cb(str(record.id))
            cb = plate_name + '_' + cb 
            sequence = str(record.seq)
            id_item = (plate_name, sequence, cb, umi)
            ids.append(id_item)
    df = pd.DataFrame(ids, columns=['plate', 'seq', 'cb','umi'])
    dedup_df = df.drop_duplicates().reset_index(drop=True)
    count_df = dedup_df.groupby(['plate','seq', 'cb']).count()
    seqcell_long = count_df.reset_index().rename(columns={'umi':'counts'})
    return seqcell_long


# %% ../01_SeqCell.ipynb 10
class SequencesCells():
    def __init__(self, df=None):
        self.table = df

    def __getitem__(self, key):
        try:
            out = self.table[key]
        except:
            out = self.table.loc[key]
        return out
    
    def select_plate(self, plate):
        df = self.table.set_index('plate').loc[plate, :].reset_index()
        return SequencesCells(df)
    
    def parse_file(self, fastq_file, plate_name=None):
        fastq_file = Path(fastq_file)
        if plate_name is None:
            plate_name = '-'.join(fastq_file.name.split('_')[0].split('-')[1:])
        self.table = parse_plate(fastq_file, plate_name)
        return self
    
    def save_table(self, path, compression='gzip'):
        self.table.to_csv(path, compression=compression)
        
    def read_csv(self, path, compression='gzip'):
        self.table = pd.read_csv(path, index_col=0, compression=compression)
        return self
    def to_wide_format(self):
        df = self.table.copy()
        df['cb'] = df.apply(lambda x: x.plate +'_'+ x.cb , axis= 1)
        df = df.pivot(index='seq', columns= 'cb', values= 'counts')
        return df
    def apply_prefix_plate_to_cb(self):
        self.table['cb'] = self.table.apply(lambda x: x.plate +'_'+ x.cb , axis= 1)

# %% ../01_SeqCell.ipynb 17
def filter_group(x, n_plates):
    if len(x['plate'].unique()) == n_plates:
        return x
    


def concat_plates(sequences_cells, n_plates=None, n_cores=None):
    if n_plates == None:
        n_plates = len(sequences_cells)
    cat_table = pd.concat([sc.table for sc in sequences_cells] )
    seq_grouped = cat_table.groupby('seq')
    if n_cores is None:
        table =seq_grouped.filter(lambda x: len(x['plate'].unique()) == n_plates).reset_index(drop=True)
    else:
        with Pool(n_cores) as pool:
            table = pd.concat(pool.starmap(filter_group, [(group, n_plates) for name, group in seq_grouped]))
    
    return SequencesCells(df=table)
