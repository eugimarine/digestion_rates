# AUTOGENERATED! DO NOT EDIT! File to edit: ../05_Digestion_profile_per_sequence.ipynb.

# %% auto 0
__all__ = ['count_sequences_from_mother', 'digestion_profile_from_count_matrix']

# %% ../05_Digestion_profile_per_sequence.ipynb 0
import numpy as np
import pandas as pd

# %% ../05_Digestion_profile_per_sequence.ipynb 4
def count_sequences_from_mother(seqcell, mother_seq, n_sequences, mnase_array, population, aggregation_per_cell='mean'):
    """
    Return digestion mother sequence.
    columns: digestion from right to left
    rows: digestion from left to right
    """
    seqcell = seqcell[(seqcell['sort_population']==population)]
    mnase_array.sort()
    count_matrices_list = []

    row_name = []
    column_name = []
    
    for mnase in mnase_array:
        count_m = np.zeros((n_sequences, n_sequences))
        df = seqcell[(seqcell['units_mnase'] == mnase)]

        for i in range(0, count_m.shape[0]):
            seq = mother_seq[:-(i)] if i != 0 else mother_seq
            row_name.append(seq)
            for j in range(count_m.shape[1]):
                seqj = seq[j:]
                counts = df.loc[df['seq']==seqj, 'counts'].aggregate(aggregation_per_cell) #sum or average counts per cell
                count_m[i, j] = counts
                column_name.append(seqj)
        count_m[np.isnan(count_m)] = 0
        count_matrices_list.append(count_m)
    count_matrix_stacked = np.stack(count_matrices_list) # 
    return count_matrix_stacked, row_name, column_name

# %% ../05_Digestion_profile_per_sequence.ipynb 6
def digestion_profile_from_count_matrix(count_matrix_stacked, mnases, digestion_direction, mother_seq, sequence_as_index=False):
    sum_counts = count_matrix_stacked.sum(axis=digestion_direction)

    if digestion_direction == 2: # digestion by end
        sequences_digested = [mother_seq] + [mother_seq[:-i] for i in range(1,sum_counts.shape[1])]
        sequences_digested.sort(key=len, reverse=True)
    elif digestion_direction == 1: # digestion by start
        sequences_digested = [mother_seq[i:] for i in range(sum_counts.shape[1])]
        sequences_digested.sort(key=len, reverse=True)
    else:
        raise ValueError('Index out of range, choose 1 for 5-3 digestion (start) or 2 for 3-5 digestion (end)')
    mnase_seq_df = pd.DataFrame(sum_counts, columns=sequences_digested, index=mnases)
    if sequence_as_index:
        mnase_seq_df = mnase_seq_df.transpose()
    return mnase_seq_df
