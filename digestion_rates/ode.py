# AUTOGENERATED! DO NOT EDIT! File to edit: ../04_ODEmodel.ipynb.

# %% auto 0
__all__ = ['plot_fitted_odes', 'initialize_params', 'k_matrix', 'ode_solver', 'plot_fitted', 'residual', 'fit_ode']

# %% ../04_ODEmodel.ipynb 0
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from lmfit import minimize, Parameters, Parameter, report_fit
import pandas as pd

# %% ../04_ODEmodel.ipynb 2
def plot_fitted_odes(data_fitted, t_fit, measured, model_result, xlim=None, ylim=None, t_name='time'):
    import seaborn as sns
    import pandas as pd
    time = measured[:,0]
    x = measured[:,1:]
    df_x = pd.DataFrame(x, columns=[f'x{i}' for i in range(x.shape[1])], index=pd.Series(time,  name=t_name)).reset_index().melt(id_vars=t_name, value_name='count', var_name='species')
    
    df_fit = pd.DataFrame(data=data_fitted, index=pd.Series(t_fit, name=t_name), columns=[f'fit_x{i}' for i in range(data_fitted.shape[1])]).reset_index()
    df_fit_long = df_fit.melt(id_vars=t_name, var_name='fit_curve_name', value_name='count')
    
    ax = sns.lineplot(data = df_fit_long, x=t_name, y='count', hue='fit_curve_name')
    ax = sns.scatterplot(data=df_x, x=t_name, y='count', hue='species')
    if xlim != None:
        ax.set_xlim(xlim)
    if ylim != None:
        ax.set_ylim(ylim)
        
        
    report_fit(model_result)
    plt.show()
    return ax

# %% ../04_ODEmodel.ipynb 5
def initialize_params(data, initial_guess='random', kin_guess=None, kout_guess=None, initial_guess_bounds=[0.0001, 1], vary_initial_conditions=False):
    """ Inizialize parameters for ODEs. 
    If initial_guess is 'random' then a vector of random variables [0,1) is created
    If kin_guess and kout_guess are None then the model doesn't include creation and distruction rate, provide a value otherwise"""
    
    initial_conditions = list(data[0,:])  
    if initial_guess == 'random':
        initial_guess = np.random.rand(len(initial_conditions) -1)
    params = Parameters()

    for nm,i in enumerate(initial_conditions):
        params.add('x'+str(nm + 1)+'0', value=i, vary=vary_initial_conditions)

    # creation rate   
    if kin_guess == None:
        params.add('k_inp', value=0, vary=False)
    else:
        params.add('k_inp', value=kin_guess)

    # reaction rates 
    for nm, k in enumerate(initial_guess):
        params.add('k'+str(nm), value=k, min=initial_guess_bounds[0], max=initial_guess_bounds[1])

    # distruction rate   
    if kout_guess == None:
        params.add('k_out', value=0, vary=False)
    else:
        params.add('k_out', value=kout_guess)
    return params

# %% ../04_ODEmodel.ipynb 9
def k_matrix(params):
    params_k_list = [k for k in params.keys() if 'k' in k]
    m = len(params_k_list)
    n = m - 1

    k = np.eye(n,m) - np.eye(n,m, k=1)
    k_values = [params[k] for k in params_k_list]
    return k_values * k

# %% ../04_ODEmodel.ipynb 12
def _master_equations(y, t, paras):
    """
    Your system of differential equations
    # f0 = -k0 * x1
    # f1 = k0 * x1 - k1 * x2
    # ...
    # fn-1 = kn-2 * x2 - kn-1 * x3
    # fn = kn-1 * xn-1
    fn need to be solve using odeint
    """
    y = np.insert(y, 0, 1)

    rates = k_matrix(paras)
    # print('rates shape', rates.shape)
    # print('y shape', y)
    dydt = rates.dot(y)
    # print('out shape', dydt.shape)
    return dydt

# %% ../04_ODEmodel.ipynb 14
def ode_solver(t, x0, paras):
    """
    Solution to the ODE x'(t) = f(t,x,k) with initial condition x(0) = x0
    """
    x = odeint(_master_equations, x0, t, args=(paras,))
    return x

# %% ../04_ODEmodel.ipynb 15
def plot_fitted(t_fit, data_fitted, measured, model_result):
    t_measured = measured[:,0]
    x_measured =  measured[:,1:]
    # plot fitted data
    plt.plot(t_fit, data_fitted, '-', linewidth=2, color='red', label='fitted data')
    for i, xi_measured in enumerate(x_measured.T):
        plt.scatter( t_measured, xi_measured, marker='o', color='b', label= 'X' + str(i))
    plt.legend()
    plt.xlim([0, np.max(t_measured)])
    plt.ylim([0, 1.1 * np.max(data_fitted)])
    # display fitted statistics
    report_fit(model_result)

    plt.show()

# %% ../04_ODEmodel.ipynb 16
def residual(paras, t, data, eps=None):

    """
    compute the residual between actual data and fitted data
    """
    x0 = [paras[x].value for x in paras.keys() if 'x' in x]
    model = ode_solver(t, x0, paras)
    if eps is None:
        return ((model - data)).ravel()
    return ((model-data) / eps).ravel()

# %% ../04_ODEmodel.ipynb 17
def fit_ode(residual_fn, params, time, x, method='leastsq', eps=None):
    kws = {'eps':eps}
    return minimize(residual_fn, params, args=(time, x), kws=kws, method=method)

# %% ../04_ODEmodel.ipynb 32
# | export 

# %% ../04_ODEmodel.ipynb 33
# | export 
