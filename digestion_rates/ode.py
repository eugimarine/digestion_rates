# AUTOGENERATED! DO NOT EDIT! File to edit: ../04_ODEmodel.ipynb.

# %% auto 0
__all__ = ['plot_fitted_odes', 'initialize_params', 'k_matrix', 'ode_solver', 'plot_fitted', 'residual', 'residual_hidden_states',
           'fit_ode']

# %% ../04_ODEmodel.ipynb 0
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from lmfit import minimize, Parameters, Parameter, report_fit
import pandas as pd

# %% ../04_ODEmodel.ipynb 3
def plot_fitted_odes(data_fitted, t_fit, measured, model_result, xlim=None, ylim=None, t_name='time'):
    import seaborn as sns
    import pandas as pd
    
    time = measured[:,0]
    x = measured[:,1:]
    df_x = pd.DataFrame(measured, columns=[t_name]+[f'x{i}' for i in range(1, x.shape[1]+1)]).melt(id_vars=t_name, value_name='count', var_name='species')
    df_x['data_type'] = ['measured'] * df_x.shape[0]
    
    df_fit = pd.DataFrame(data=data_fitted, index=pd.Series(t_fit, name=t_name), columns=[f'x{i}' for i in range(data_fitted.shape[1])]).reset_index()
    df_fit_long = df_fit.melt(id_vars=t_name, var_name='species', value_name='count')
    df_fit_long['data_type'] = ['fit'] * df_fit_long.shape[0]
    
    join_fit_x = pd.concat((df_fit_long, df_x), ignore_index=True)
    
    ax = sns.lineplot(data = join_fit_x, x=t_name, y='count', hue='species', style='data_type', markers=['.', 'o'])

    if xlim != None:
        ax.set_xlim(xlim)
    if ylim != None:
        ax.set_ylim(ylim)
        
        
    report_fit(model_result)
    plt.show()
    return ax

# %% ../04_ODEmodel.ipynb 6
def initialize_params(data, initial_rate_guess='random', init_hidden=None, kout_guess=None, initial_guess_bounds=[0.0001, 1], vary_initial_conditions=True):
    """ Inizialize parameters for ODEs. 
    If initial_guess is 'random' then a vector of random variables [0,1) is created
    If kin_guess and kout_guess are None then the model doesn't include creation and distruction rate, provide a value otherwise"""
    
    if init_hidden is None:
        raise Exception('Initial hidden population needs to be provided')
    
    initial_conditions =  [init_hidden] + list(data[0,:]) 

    if initial_rate_guess == 'random':
        initial_rate_guess = np.random.rand(len(initial_conditions) -1)
        
    params = Parameters()
    
    #creation rate
    params.add('k_inp', value=0, vary=False)

    for nm,i in enumerate(initial_conditions):
        params.add('x'+str(nm)+'0', value=i, min=0, vary=vary_initial_conditions)

    # reaction rates 
    for nm, k in enumerate(initial_rate_guess):
        params.add('k'+str(nm), value=k, min=initial_guess_bounds[0], max=initial_guess_bounds[1])

    # distruction rate   
    if kout_guess == None:
        params.add('k_out', value=0, vary=False)
    else:
        params.add('k_out', value=kout_guess)
    return params

# %% ../04_ODEmodel.ipynb 10
def k_matrix(params):
    params_k_list = [k for k in params.keys() if 'k' in k]
    m = len(params_k_list)
    n = m - 1

    k = np.eye(n,m) - np.eye(n,m, k=1)
    k_values = [params[k] for k in params_k_list]
    return k_values * k

# %% ../04_ODEmodel.ipynb 13
def _master_equations(y, t, paras):
    """
    Your system of differential equations
    # f0 = -k0 * x1
    # f1 = k0 * x1 - k1 * x2
    # ...
    # fn-1 = kn-2 * x2 - kn-1 * x3
    # fn = kn-1 * xn-1
    fn need to be solve using odeint
    """
    y = np.insert(y, 0, 1)
    rates = k_matrix(paras)
    dydt = rates.dot(y)
    return dydt

# %% ../04_ODEmodel.ipynb 15
def ode_solver(t, x0, paras):
    """
    Solution to the ODE x'(t) = f(t,x,k) with initial condition x(0) = x0
    """
    x = odeint(_master_equations, x0, t, args=(paras,))
    return x

# %% ../04_ODEmodel.ipynb 16
def plot_fitted(t_fit, data_fitted, measured, model_result):
    t_measured = measured[:,0]
    x_measured =  measured[:,1:]
    # plot fitted data
    plt.plot(t_fit, data_fitted, '-', linewidth=2, color='red', label='fitted data')
    for i, xi_measured in enumerate(x_measured.T):
        plt.scatter( t_measured, xi_measured, marker='o', color='b', label= 'X' + str(i))
    plt.legend()
    plt.xlim([0, np.max(t_measured)])
    plt.ylim([0, 1.1 * np.max(data_fitted)])
    # display fitted statistics
    report_fit(model_result)

    plt.show()

# %% ../04_ODEmodel.ipynb 17
def residual(paras, t, data, eps=None):

    """
    compute the residual between actual data and fitted data
    """
    x0 = [paras[x].value for x in paras.keys() if 'x' in x]
    model = ode_solver(t, x0, paras)
    if eps is None:
        return ((model - data)).ravel()
    return ((model-data) / eps).ravel()

# %% ../04_ODEmodel.ipynb 18
def residual_hidden_states(paras, t, data, eps=None):

    """
    compute the residual between actual data and fitted data
    first column of data should be 
    """
    x0 = [paras[x].value for x in paras.keys() if 'x' in x]
    model = ode_solver(t, x0, paras)
    if eps is None:
        return ((model[:,1:] - data)).ravel()
    return ((model[:,1:] - data) / eps).ravel()

# %% ../04_ODEmodel.ipynb 20
def fit_ode(residual_fn, params, time, x, method='leastsq', eps=None):
    kws = {'eps':eps}
    return minimize(residual_fn, params, args=(time, x), kws=kws, method=method)

# %% ../04_ODEmodel.ipynb 33
# | export 

# %% ../04_ODEmodel.ipynb 34
# | export 
